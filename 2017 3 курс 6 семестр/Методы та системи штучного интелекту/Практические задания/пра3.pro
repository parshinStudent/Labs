/*
У будь-якому разі Пролог перевірить весь список, і тому знайде всі входження X в нього.
    owned(X, [X|_]).
    owned(X, [_|Tail):-owned(X,Tail).
    
Якщо треба знайти єдиний розв’язок (лише перше входження X), 
то потрібно скористатися відсіканням:
    owned(X, [X|_]):-!.
    owned(X, [_|Tail]):-owned(X, Tail).
    
Якщо перший список порожній, то L3 співпадає з L2. Інакше для того, щоб дописати елементи 
L2 до L1, треба зчепити хвіст L1 та весь L2, а потім до отриманого списку попереду приписати голову L1:
    konk([], L, L).
    konk([X|Tail1], L, [X]Tail2]:-konk(Tail1, L, Tail2).
    
Додавання елемента X у список L виконується дуже просто – достатньо записати 
результуючий список як [X|L]. Цю дію також можна оформити у вигляді предиката:
    add(X, L, [X|L]).
    
Предикат для видалення елемента зі списку також реалізується за допомогою рекурсії:
    видалити(X, [X|Tail], Tail). %якщо X – голова списку, то результатом видалення буде хвіст цього списку
    видалити(X, [Y|Tail1], [Y|Tail2]):-видалити(X, Tail1, Tail2). %інакше видалятимемо X у хвості списку
    
Нарешті, часто треба знаходити кількість елементів списку:
    довжина([], 0).
    довжина([_|Tail], N):-довжина(Tail, N1), N is N1+1.
    
Знайти сумму списку    
    сума_списку([],0).
    сума_списку([H|T],S):- number(H),
    сума_списку(T,S1), S = S1+H.

 */
even(Numb):-Numb mod 2=:=0.

 
p1:- write("aaaaa"),nl.
writeHello:- write("Hello world!"), nl.
p2:- p555().
List = [ 1,2,3,4,5 ].
p(X) :- X is 3+ 7.

lessThanZero(Numb):- Numb < 0.

summ([],0).
summ([H|Tail], S):- lessThanZero(H),
summ(Tail,S1), S is S1 + H.